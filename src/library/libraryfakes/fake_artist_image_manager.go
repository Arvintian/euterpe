// Code generated by counterfeiter. DO NOT EDIT.
package libraryfakes

import (
	"context"
	"io"
	"sync"

	"github.com/ironsmile/euterpe/src/library"
)

type FakeArtistImageManager struct {
	FindAndSaveArtistImageStub        func(context.Context, int64, library.ImageSize) (io.ReadCloser, error)
	findAndSaveArtistImageMutex       sync.RWMutex
	findAndSaveArtistImageArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 library.ImageSize
	}
	findAndSaveArtistImageReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	findAndSaveArtistImageReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	RemoveArtistImageStub        func(context.Context, int64) error
	removeArtistImageMutex       sync.RWMutex
	removeArtistImageArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	removeArtistImageReturns struct {
		result1 error
	}
	removeArtistImageReturnsOnCall map[int]struct {
		result1 error
	}
	SaveArtistImageStub        func(context.Context, int64, io.Reader) error
	saveArtistImageMutex       sync.RWMutex
	saveArtistImageArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 io.Reader
	}
	saveArtistImageReturns struct {
		result1 error
	}
	saveArtistImageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImage(arg1 context.Context, arg2 int64, arg3 library.ImageSize) (io.ReadCloser, error) {
	fake.findAndSaveArtistImageMutex.Lock()
	ret, specificReturn := fake.findAndSaveArtistImageReturnsOnCall[len(fake.findAndSaveArtistImageArgsForCall)]
	fake.findAndSaveArtistImageArgsForCall = append(fake.findAndSaveArtistImageArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 library.ImageSize
	}{arg1, arg2, arg3})
	stub := fake.FindAndSaveArtistImageStub
	fakeReturns := fake.findAndSaveArtistImageReturns
	fake.recordInvocation("FindAndSaveArtistImage", []interface{}{arg1, arg2, arg3})
	fake.findAndSaveArtistImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImageCallCount() int {
	fake.findAndSaveArtistImageMutex.RLock()
	defer fake.findAndSaveArtistImageMutex.RUnlock()
	return len(fake.findAndSaveArtistImageArgsForCall)
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImageCalls(stub func(context.Context, int64, library.ImageSize) (io.ReadCloser, error)) {
	fake.findAndSaveArtistImageMutex.Lock()
	defer fake.findAndSaveArtistImageMutex.Unlock()
	fake.FindAndSaveArtistImageStub = stub
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImageArgsForCall(i int) (context.Context, int64, library.ImageSize) {
	fake.findAndSaveArtistImageMutex.RLock()
	defer fake.findAndSaveArtistImageMutex.RUnlock()
	argsForCall := fake.findAndSaveArtistImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImageReturns(result1 io.ReadCloser, result2 error) {
	fake.findAndSaveArtistImageMutex.Lock()
	defer fake.findAndSaveArtistImageMutex.Unlock()
	fake.FindAndSaveArtistImageStub = nil
	fake.findAndSaveArtistImageReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtistImageManager) FindAndSaveArtistImageReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.findAndSaveArtistImageMutex.Lock()
	defer fake.findAndSaveArtistImageMutex.Unlock()
	fake.FindAndSaveArtistImageStub = nil
	if fake.findAndSaveArtistImageReturnsOnCall == nil {
		fake.findAndSaveArtistImageReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.findAndSaveArtistImageReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtistImageManager) RemoveArtistImage(arg1 context.Context, arg2 int64) error {
	fake.removeArtistImageMutex.Lock()
	ret, specificReturn := fake.removeArtistImageReturnsOnCall[len(fake.removeArtistImageArgsForCall)]
	fake.removeArtistImageArgsForCall = append(fake.removeArtistImageArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.RemoveArtistImageStub
	fakeReturns := fake.removeArtistImageReturns
	fake.recordInvocation("RemoveArtistImage", []interface{}{arg1, arg2})
	fake.removeArtistImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtistImageManager) RemoveArtistImageCallCount() int {
	fake.removeArtistImageMutex.RLock()
	defer fake.removeArtistImageMutex.RUnlock()
	return len(fake.removeArtistImageArgsForCall)
}

func (fake *FakeArtistImageManager) RemoveArtistImageCalls(stub func(context.Context, int64) error) {
	fake.removeArtistImageMutex.Lock()
	defer fake.removeArtistImageMutex.Unlock()
	fake.RemoveArtistImageStub = stub
}

func (fake *FakeArtistImageManager) RemoveArtistImageArgsForCall(i int) (context.Context, int64) {
	fake.removeArtistImageMutex.RLock()
	defer fake.removeArtistImageMutex.RUnlock()
	argsForCall := fake.removeArtistImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtistImageManager) RemoveArtistImageReturns(result1 error) {
	fake.removeArtistImageMutex.Lock()
	defer fake.removeArtistImageMutex.Unlock()
	fake.RemoveArtistImageStub = nil
	fake.removeArtistImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtistImageManager) RemoveArtistImageReturnsOnCall(i int, result1 error) {
	fake.removeArtistImageMutex.Lock()
	defer fake.removeArtistImageMutex.Unlock()
	fake.RemoveArtistImageStub = nil
	if fake.removeArtistImageReturnsOnCall == nil {
		fake.removeArtistImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeArtistImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtistImageManager) SaveArtistImage(arg1 context.Context, arg2 int64, arg3 io.Reader) error {
	fake.saveArtistImageMutex.Lock()
	ret, specificReturn := fake.saveArtistImageReturnsOnCall[len(fake.saveArtistImageArgsForCall)]
	fake.saveArtistImageArgsForCall = append(fake.saveArtistImageArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 io.Reader
	}{arg1, arg2, arg3})
	stub := fake.SaveArtistImageStub
	fakeReturns := fake.saveArtistImageReturns
	fake.recordInvocation("SaveArtistImage", []interface{}{arg1, arg2, arg3})
	fake.saveArtistImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtistImageManager) SaveArtistImageCallCount() int {
	fake.saveArtistImageMutex.RLock()
	defer fake.saveArtistImageMutex.RUnlock()
	return len(fake.saveArtistImageArgsForCall)
}

func (fake *FakeArtistImageManager) SaveArtistImageCalls(stub func(context.Context, int64, io.Reader) error) {
	fake.saveArtistImageMutex.Lock()
	defer fake.saveArtistImageMutex.Unlock()
	fake.SaveArtistImageStub = stub
}

func (fake *FakeArtistImageManager) SaveArtistImageArgsForCall(i int) (context.Context, int64, io.Reader) {
	fake.saveArtistImageMutex.RLock()
	defer fake.saveArtistImageMutex.RUnlock()
	argsForCall := fake.saveArtistImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtistImageManager) SaveArtistImageReturns(result1 error) {
	fake.saveArtistImageMutex.Lock()
	defer fake.saveArtistImageMutex.Unlock()
	fake.SaveArtistImageStub = nil
	fake.saveArtistImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtistImageManager) SaveArtistImageReturnsOnCall(i int, result1 error) {
	fake.saveArtistImageMutex.Lock()
	defer fake.saveArtistImageMutex.Unlock()
	fake.SaveArtistImageStub = nil
	if fake.saveArtistImageReturnsOnCall == nil {
		fake.saveArtistImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveArtistImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtistImageManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findAndSaveArtistImageMutex.RLock()
	defer fake.findAndSaveArtistImageMutex.RUnlock()
	fake.removeArtistImageMutex.RLock()
	defer fake.removeArtistImageMutex.RUnlock()
	fake.saveArtistImageMutex.RLock()
	defer fake.saveArtistImageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeArtistImageManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ library.ArtistImageManager = new(FakeArtistImageManager)
